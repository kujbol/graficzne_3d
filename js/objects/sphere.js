// Generated by CoffeeScript 1.10.0
(function() {
  var object_count,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  object_count = 0;

  window.Sphere = (function(superClass) {
    extend(Sphere, superClass);

    function Sphere(points) {
      if (points == null) {
        points = null;
      }
      Sphere.__super__.constructor.call(this, "Shpere_" + object_count);
      object_count++;
      this.settings = new SphereSettings(this);
      this.settings.load_settings();
      if (points === null) {
        this.points = this.create_points();
      } else {
        this.points = points;
      }
      this.create_triangles();
    }

    Sphere.prototype.create_points = function() {
      var i, l, p, points, t;
      t = (1.0 + math.sqrt(5.0)) / 2.0;
      l = math.sqrt(1 + t * t);
      t /= l;
      l = 1 / l;
      if (this.points.length > 0) {
        p = this.points;
      } else {
        p = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j <= 12; i = ++j) {
            results.push({
              color: null
            });
          }
          return results;
        })();
      }
      return points = [new Point(-l, t, 0, p[0].color), new Point(l, t, 0, p[1].color), new Point(-l, -t, 0, p[2].color), new Point(l, -t, 0, p[3].color), new Point(0, -l, t, p[4].color), new Point(0, l, t, p[5].color), new Point(0, -l, -t, p[6].color), new Point(0, l, -t, p[7].color), new Point(t, 0, -l, p[8].color), new Point(t, 0, l, p[9].color), new Point(-t, 0, -l, p[10].color), new Point(-t, 0, l, p[11].color)];
    };

    Sphere.prototype.create_triangles = function(new_points) {
      var a, b, c, i, is_in_middle, j, k, len, p, ref, ref1, results, triangle, triangles2;
      if (new_points == null) {
        new_points = null;
      }
      if (new_points) {
        this.points = new_points;
        is_in_middle = false;
      } else {
        is_in_middle = true;
      }
      p = this.points;
      this.triangles = [new Triangle(p[0], p[11], p[5]), new Triangle(p[0], p[5], p[1]), new Triangle(p[0], p[1], p[7]), new Triangle(p[0], p[7], p[10]), new Triangle(p[0], p[10], p[11]), new Triangle(p[1], p[5], p[9]), new Triangle(p[5], p[11], p[4]), new Triangle(p[11], p[10], p[2]), new Triangle(p[10], p[7], p[6]), new Triangle(p[7], p[1], p[8]), new Triangle(p[3], p[9], p[4]), new Triangle(p[3], p[4], p[2]), new Triangle(p[3], p[2], p[6]), new Triangle(p[3], p[6], p[8]), new Triangle(p[3], p[8], p[9]), new Triangle(p[4], p[9], p[5]), new Triangle(p[2], p[4], p[11]), new Triangle(p[6], p[2], p[10]), new Triangle(p[8], p[6], p[7]), new Triangle(p[9], p[8], p[1])];
      results = [];
      for (i = j = 0, ref = this.settings.recursive.value; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        triangles2 = [];
        ref1 = this.triangles;
        for (k = 0, len = ref1.length; k < len; k++) {
          triangle = ref1[k];
          a = this.middle_point(triangle.p1, triangle.p2, is_in_middle);
          b = this.middle_point(triangle.p2, triangle.p3, is_in_middle);
          c = this.middle_point(triangle.p3, triangle.p1, is_in_middle);
          triangles2.push(new Triangle(triangle.p1, a, c));
          triangles2.push(new Triangle(triangle.p2, b, a));
          triangles2.push(new Triangle(triangle.p3, c, b));
          triangles2.push(new Triangle(a, b, c));
        }
        results.push(this.triangles = triangles2);
      }
      return results;
    };

    Sphere.prototype.middle_point = function(p1, p2, is_in_middle) {
      var j, len, length, middle, point, ref;
      if (is_in_middle == null) {
        is_in_middle = true;
      }
      middle = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);
      if (is_in_middle) {
        length = math.sqrt(middle.x * middle.x + middle.y * middle.y + middle.z * middle.z);
      } else {
        length = math.sqrt(middle.x * middle.x + middle.y * middle.y + middle.z * middle.z);
      }
      middle.x /= length;
      middle.y /= length;
      middle.z /= length;
      ref = this.points;
      for (j = 0, len = ref.length; j < len; j++) {
        point = ref[j];
        if (point.is_same(middle)) {
          return point;
        }
      }
      this.points.push(middle);
      return middle;
    };

    return Sphere;

  })(BaseObject);

}).call(this);

//# sourceMappingURL=sphere.js.map
