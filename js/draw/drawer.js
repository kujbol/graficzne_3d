// Generated by CoffeeScript 1.10.0
(function() {
  window.Drawer = (function() {
    function Drawer(canvas, camera) {
      var i, j;
      this.canvas = canvas;
      this.camera = camera;
      this.ctx = this.canvas.getContext("2d");
      this.zbuffor = (function() {
        var k, ref, results;
        results = [];
        for (j = k = 0, ref = this.canvas.width; 0 <= ref ? k <= ref : k >= ref; j = 0 <= ref ? ++k : --k) {
          results.push((function() {
            var l, ref1, results1;
            results1 = [];
            for (i = l = 0, ref1 = this.canvas.height; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
              results1.push(100000);
            }
            return results1;
          }).call(this));
        }
        return results;
      }).call(this);
      this.canvas_array = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      this.actual_triangle = null;
      this.actual_object = null;
    }

    Drawer.prototype.draw_objects = function(objects) {
      var k, len1, object;
      this.ctx = this.canvas.getContext("2d");
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this._clear_buffor();
      this.canvas_array = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      for (k = 0, len1 = objects.length; k < len1; k++) {
        object = objects[k];
        this.actual_object = object;
        if (object.settings.filled.value) {
          this.draw_triangles(object);
        } else {
          this.draw_lines(object);
        }
      }
      return this.ctx.putImageData(this.canvas_array, 0, 0);
    };

    Drawer.prototype.draw_lines = function(object) {
      var k, len1, p1, p2, p3, ref, results, triangle;
      ref = object.triangles;
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        triangle = ref[k];
        triangle = this.camera.cast_triangle(triangle);
        this.actual_triangle = triangle;
        p1 = this.to_screen_metrix(triangle.p1);
        p2 = this.to_screen_metrix(triangle.p2);
        p3 = this.to_screen_metrix(triangle.p3);
        this.__draw_line(p1.x, p1.y, p2.x, p2.y, true);
        this.__draw_line(p2.x, p2.y, p3.x, p3.y, true);
        results.push(this.__draw_line(p3.x, p3.y, p1.x, p1.y, true));
      }
      return results;
    };

    Drawer.prototype.draw_triangles = function(object) {
      var k, len1, ref, results, triangle;
      ref = object.triangles;
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        triangle = ref[k];
        triangle = this.camera.cast_triangle(triangle);
        triangle = this.triangle_to_screen(triangle);
        this.actual_triangle = triangle;
        results.push(this._draw_triangle(triangle));
      }
      return results;
    };

    Drawer.prototype.__draw_line = function(x1, y1, x2, y2) {
      var b, dx, dy, g, i, k, len, r, ref, ref1, ref2, ref3, ref4, x, y, z;
      if (Math.abs(x2 - x1) >= Math.abs(y2 - y1)) {
        len = Math.abs(x2 - x1);
      } else {
        len = Math.abs(y2 - y1);
      }
      dx = (x2 - x1) / len;
      dy = (y2 - y1) / len;
      x = x1 + 0.5 * ((ref = dx > 0) != null ? ref : {
        1: -1
      });
      y = y1 + 0.5 * ((ref1 = dy > 0) != null ? ref1 : {
        1: -1
      });
      ref2 = this._count_z_and_color(x, y), z = ref2[0], r = ref2[1], g = ref2[2], b = ref2[3];
      this._plot(Math.round(x), Math.round(y), z - 5, 0, 0, 0);
      for (i = k = 0, ref3 = len; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {
        ref4 = this._count_z_and_color(x, y), z = ref4[0], r = ref4[1], g = ref4[2], b = ref4[3];
        this._plot(Math.round(x), Math.round(y), z, r, g, b);
        x = x + dx;
        y = y + dy;
      }
      return this._plot(Math.round(x - dx), Math.round(y - dy), z - 5, 0, 0, 0);
    };

    Drawer.prototype._draw_triangle = function(triangle) {
      var p1, p2, p3, p4, points;
      points = [triangle.p1, triangle.p2, triangle.p3].sort(function(a, b) {
        return a.y - b.y;
      });
      p1 = points[0], p2 = points[1], p3 = points[2];
      if (p2.y === p3.y) {
        return this._fill_bottom_flat_triangle(p1, p2, p3);
      } else if (p1.y === p2.y) {
        return this._fill_top_flat_triangle(p1, p2, p3);
      } else {
        p4 = new Point(Math.round(p1.x + (p2.y - p1.y) / (p3.y - p1.y) * (p3.x - p1.x)), p2.y, (p2.y - p1.y) / (p3.y - p1.y) * (p3.z - p1.z));
        this._fill_bottom_flat_triangle(p1, p2, p4);
        return this._fill_top_flat_triangle(p2, p4, p3);
      }
    };

    Drawer.prototype._fill_bottom_flat_triangle = function(p1, p2, p3) {
      var curx1, curx2, invslope1, invslope2, k, ref, ref1, results, scanlineY;
      invslope1 = (p2.x - p1.x) / (p2.y - p1.y);
      invslope2 = (p3.x - p1.x) / (p3.y - p1.y);
      curx1 = p1.x;
      curx2 = p1.x;
      results = [];
      for (scanlineY = k = ref = p1.y, ref1 = p2.y; ref <= ref1 ? k <= ref1 : k >= ref1; scanlineY = ref <= ref1 ? ++k : --k) {
        this.__draw_line(Math.round(curx1), scanlineY, Math.round(curx2), scanlineY);
        curx1 += invslope1;
        results.push(curx2 += invslope2);
      }
      return results;
    };

    Drawer.prototype._fill_top_flat_triangle = function(p1, p2, p3) {
      var curx1, curx2, invslope1, invslope2, k, ref, ref1, results, scanlineY;
      invslope1 = (p3.x - p1.x) / (p3.y - p1.y);
      invslope2 = (p3.x - p2.x) / (p3.y - p2.y);
      curx1 = p3.x;
      curx2 = p3.x;
      results = [];
      for (scanlineY = k = ref = p3.y, ref1 = p1.y; ref <= ref1 ? k <= ref1 : k >= ref1; scanlineY = ref <= ref1 ? ++k : --k) {
        curx1 -= invslope1;
        curx2 -= invslope2;
        results.push(this.__draw_line(Math.round(curx1), scanlineY, Math.round(curx2), scanlineY));
      }
      return results;
    };

    Drawer.prototype._plot = function(x, y, z, r, g, b) {
      if ((0 < x && x < this.canvas.width) && (0 < y && y < this.canvas.height)) {
        if (this.zbuffor[x][y] >= z) {
          this.zbuffor[x][y] = z;
          return this._set(x, y, r, g, b);
        }
      }
    };

    Drawer.prototype._set = function(x, y, r, g, b) {
      this.canvas_array.data[4 * (x + y * this.canvas.width)] = r;
      this.canvas_array.data[4 * (x + y * this.canvas.width) + 1] = g;
      this.canvas_array.data[4 * (x + y * this.canvas.width) + 2] = b;
      return this.canvas_array.data[4 * (x + y * this.canvas.width) + 3] = 255;
    };

    Drawer.prototype._count_z_and_color = function(x, y) {
      var b, b1, b2, b3, g, g1, g2, g3, p1, p1_percent, p2, p2_percent, p3, p3_percent, r, r1, r2, r3, ref, ref1, ref2, ref3, sum, z;
      ref = [this.actual_triangle.p1, this.actual_triangle.p2, this.actual_triangle.p3], p1 = ref[0], p2 = ref[1], p3 = ref[2];
      sum = this._are_of_triangle(p1, p2, p3.x, p3.y);
      p1_percent = this._are_of_triangle(p2, p3, x, y);
      p2_percent = this._are_of_triangle(p1, p3, x, y);
      p3_percent = this._are_of_triangle(p1, p2, x, y);
      z = (p1.z * p1_percent + p2.z * p2_percent + p3.z * p3_percent) / sum;
      if (this.actual_object.settings.colorful.value && this.actual_object.settings.simple_color.value === false && this.actual_object.settings.filled.value) {
        ref1 = p1.color, r1 = ref1[0], g1 = ref1[1], b1 = ref1[2];
        ref2 = p2.color, r2 = ref2[0], g2 = ref2[1], b2 = ref2[2];
        ref3 = p3.color, r3 = ref3[0], g3 = ref3[1], b3 = ref3[2];
        r = (r1 * p1_percent + r2 * p2_percent + r3 * p3_percent) / sum;
        g = (g1 * p1_percent + g2 * p2_percent + g3 * p3_percent) / sum;
        b = (b1 * p1_percent + b2 * p2_percent + b3 * p3_percent) / sum;
        return [z, r, g, b];
      } else if (this.actual_object.settings.colorful.value && (this.actual_object.settings.simple_color.value || !this.actual_object.settings.filled.value)) {
        return [z, p1.color[0], p1.color[1], p1.color[2]];
      } else {
        return [z, 0, 0, 0];
      }
    };

    Drawer.prototype._clear_buffor = function() {
      var a, b, k, ref, results;
      results = [];
      for (a = k = 0, ref = this.canvas.width; 0 <= ref ? k <= ref : k >= ref; a = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (b = l = 0, ref1 = this.canvas.height; 0 <= ref1 ? l <= ref1 : l >= ref1; b = 0 <= ref1 ? ++l : --l) {
            results1.push(this.zbuffor[a][b] = 100000);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Drawer.prototype._are_of_triangle = function(p1, p2, x, y) {
      return (1 / 2) * Math.abs((x - p1.x) * (y - p2.y) - (y - p1.y) * (x - p2.x));
    };

    Drawer.prototype.triangle_to_screen = function(triangle) {
      return new Triangle(this.to_screen_metrix(triangle.p1), this.to_screen_metrix(triangle.p2), this.to_screen_metrix(triangle.p3));
    };

    Drawer.prototype.to_screen_metrix = function(point) {
      var x, y, z;
      x = Math.round((point.x + 1.0) / 2 * this.canvas.width);
      y = Math.round((point.y + 1.0) / 2 * this.canvas.height);
      z = Math.round((point.z + 1.0) / 2 * this.canvas.height);
      return new Point(x, y, z, point.color);
    };

    return Drawer;

  })();

}).call(this);

//# sourceMappingURL=drawer.js.map
